<!DOCTYPE html>
<html
  dir="ltr"
  lang="zh-cn"
  data-theme=""
><head>
  <title>
    
      杨海瑞
        |
        防缓存击穿利器singleflight介绍


      


    
  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.80.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta
    name="description"
    content="
      
Per aspera ad astra.
循此苦旅，终抵群星。



    "
  />
  
  
  
  <link
    rel="stylesheet"
    href="/css/main.min.7ca9a7b7632c545387f4ab9f7f943afeab89e7ed1c092ce9fb39263257779ce5.css"
    integrity="sha256-fKmnt2MsVFOH9Kuff5Q6/quJ5&#43;0cCSzp&#43;zkmMld3nOU="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="/css/markupHighlight.min.8f07fad4abedfd5eb1396c6fef85ba7ec00ec867a79fb545c9db18df87f6760a.css"
    integrity="sha256-jwf61Kvt/V6xOWxv74W6fsAOyGenn7VFydsY34f2dgo="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
    crossorigin="anonymous"
  />
  
  <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png" />

  <link rel="canonical" href="https://yanghairui.life/post/%E9%98%B2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%88%A9%E5%99%A8singleflight%E4%BB%8B%E7%BB%8D/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/js/anatole-header.min.413f798d8aa82610bef17a5ca1d7e962ec185be395f1aeb3f45d1891af568b65.js"
    integrity="sha256-QT95jYqoJhC&#43;8XpcodfpYuwYW&#43;OV8a6z9F0Yka9Wi2U="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/js/anatole-theme-switcher.min.fcf9526f15b3b4e08472de192969ab28a4cdcb32ac94f83e85a8b84e9b45acd2.js"
      integrity="sha256-/PlSbxWztOCEct4ZKWmrKKTNyzKslPg&#43;hai4TptFrNI="
      crossorigin="anonymous"
    ></script>

  


  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="防缓存击穿利器singleflight介绍"/>
<meta name="twitter:description" content="缓存击穿 一般一个并发量大的服务，往往会在服务和数据库之间增加一层缓存，来减轻数据库的压力，因为数据库在高并发时往往会是整个系统的瓶颈。大概的过程就是查询时，先从缓存中查询，缓存中查不到，则从数据库中查询，并把数据回填到缓存中，再返回给用户，那么下次用户访问同一份数据时，就可以命中缓存而不用访问数据库，以此减轻数据库的压力。而在系统刚启动时一般也会采用缓存预热的方式，把数据库中的一些可能的热点数据预先加载到缓存中，以防止系统刚刚启动时数据库的压力过大。
而缓存中的key往往都需要有过期时间，当缓存中(Redis或者Memcached)的某个热点key，在承受大量并发时突然过期，导致查询这个key的所有请求穿透缓存到达数据库，增大数据库的压力，严重时甚至可能让数据库宕机，这就是缓存击穿。就像下图这样，所有请求都透传到了数据库：
解决这个问题比较重型的武器是分布式锁，即缓存miss后访问数据库需要先获取分布式锁，拿到分布式锁后才能从数据库中查到想要的数据，没拿到分布式锁就需要等待其他占有锁的线程完成从数据库中取数据和缓存的回填操作后，再从缓存中获取数据并返回。
但是这种解决方式消耗资源过大，且并且不是每个系统都需要分布式锁。singleflight就是一个解决该问题的利器。
Singleflight的使用 singleflight 库，直译过来就是单飞，这个库的主要作用就是将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果即可。当并发访问数据库中某个数据时，可以通过singleflight保证在一定的时间周期内，同一个key的并发访问实际上只有一次请求真正访问数据库，以此来大大降低数据库的压力，如下图：
使用方式 首先获取这个包"/>



  


  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "post",
        "name": "防缓存击穿利器singleflight介绍",
        "headline": "防缓存击穿利器singleflight介绍",
        "alternativeHeadline": "",
        "description": "
      
        缓存击穿 一般一个并发量大的服务，往往会在服务和数据库之间增加一层缓存，来减轻数据库的压力，因为数据库在高并发时往往会是整个系统的瓶颈。大概的过程就是查询时，先从缓存中查询，缓存中查不到，则从数据库中查询，并把数据回填到缓存中，再返回给用户，那么下次用户访问同一份数据时，就可以命中缓存而不用访问数据库，以此减轻数据库的压力。而在系统刚启动时一般也会采用缓存预热的方式，把数据库中的一些可能的热点数据预先加载到缓存中，以防止系统刚刚启动时数据库的压力过大。\n而缓存中的key往往都需要有过期时间，当缓存中(Redis或者Memcached)的某个热点key，在承受大量并发时突然过期，导致查询这个key的所有请求穿透缓存到达数据库，增大数据库的压力，严重时甚至可能让数据库宕机，这就是缓存击穿。就像下图这样，所有请求都透传到了数据库：\n解决这个问题比较重型的武器是分布式锁，即缓存miss后访问数据库需要先获取分布式锁，拿到分布式锁后才能从数据库中查到想要的数据，没拿到分布式锁就需要等待其他占有锁的线程完成从数据库中取数据和缓存的回填操作后，再从缓存中获取数据并返回。\n但是这种解决方式消耗资源过大，且并且不是每个系统都需要分布式锁。singleflight就是一个解决该问题的利器。\nSingleflight的使用 singleflight 库，直译过来就是单飞，这个库的主要作用就是将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果即可。当并发访问数据库中某个数据时，可以通过singleflight保证在一定的时间周期内，同一个key的并发访问实际上只有一次请求真正访问数据库，以此来大大降低数据库的压力，如下图：\n使用方式 首先获取这个包


      


    ",
        "inLanguage": "zh-cn",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/yanghairui.life\/post\/%E9%98%B2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%88%A9%E5%99%A8singleflight%E4%BB%8B%E7%BB%8D\/"
        },
        "author" : {
            "@type": "Person",
            "name": "杨海瑞"
        },
        "creator" : {
            "@type": "Person",
            "name": "杨海瑞"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "杨海瑞"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "杨海瑞"
        },
        "copyrightYear" : "2021",
        "dateCreated": "2021-11-21T10:18:27.00Z",
        "datePublished": "2021-11-21T10:18:27.00Z",
        "dateModified": "2021-11-21T10:18:27.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "杨海瑞",
            "url": "https://yanghairui.life",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/yanghairui.life\/favicons\/favicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
      ]

    ,
        "url" : "https:\/\/yanghairui.life\/post\/%E9%98%B2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%88%A9%E5%99%A8singleflight%E4%BB%8B%E7%BB%8D\/",
        "wordCount" : "1152",
        "genre" : [ 
      
      "golang"

    ],
        "keywords" : [ 
      
      "golang"

    
      
        ,

      
      "缓存击穿"

    ]
    }
  </script>



</head>
<body>
    <header><div
  class="page-top 
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true"></span>
    <span aria-hidden="true"></span>
    <span aria-hidden="true"></span>
  </a>
  <nav>
    <ul class="nav__list" id="navMenu">
      <div class="nav__links">
        
        
          
          <li>
            <a
              
              href="/"
              
              title=""
              >Home</a
            >
          </li>

        
          
          <li>
            <a
              
              href="/post/"
              
              title=""
              >Posts</a
            >
          </li>

        
          
          <li>
            <a
              
              href="/portfolio/"
              
              title=""
              >Portfolio</a
            >
          </li>

        
          
          <li>
            <a
              
              href="/about/"
              
              title=""
              >About</a
            >
          </li>

        
          
          <li>
            <a
              
              href="/contact/"
              
              title=""
              >Contact</a
            >
          </li>

        
      </div>
      <ul>
        
        
          <li>
            <a class="theme-switch" title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </li>

        
      </ul>
    </ul>
  </nav>
</div>
</header>
    <div class="wrapper">
      <aside><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="logo-title">
      <div class="title">
        <img src="/images/profile5.jpg" alt="profile picture" />
        <h3 title=""><a href="/">Harry Yang&#39;s Website</a></h3>
        <div class="description">
          <p><br />Per aspera ad astra.<br />循此苦旅，终抵群星。<br /></p>
        </div>
      </div>
    </div>
    <ul class="social-links">
      
        <li>
          <a href="https://stackoverflow.com/users/12924262/horace-yang" rel="me" aria-label="StackOverFlow" title="StackOverFlow">
            <i class="fab fa-stack-overflow fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li>
          <a href="https://github.com/harryyann" rel="me" aria-label="GitHub" title="GitHub">
            <i class="fab fa-github fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li>
          <a href="https://www.zhihu.com/people/yang-hai-rui-88" rel="me" aria-label="zhihu" title="zhihu">
            <i class="fab fa-zhihu fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
        <li>
          <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=941811450@qq.com" rel="me" aria-label="e-mail" title="e-mail">
            <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
          </a>
        </li>

      
    </ul>
  </div><footer class="footer footer--sidebar">
  <div class="by_farbox">
    <ul class="footer__list">
      <li class="footer__item">
        &copy;
        
          2021-2022

        
      </li>
      
    </ul>
  </div>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.bdc7b23aff63497a79433b3920b03e2473399d90ad4c2d87cf7c08d33d61966f.js"
    integrity="sha256-vceyOv9jSXp5Qzs5ILA&#43;JHM5nZCtTC2Hz3wI0z1hlm8="
    crossorigin="anonymous"
  ></script></div>
</aside>
      <main>
        <div class="autopagerize_page_element">
          <div class="content">
  <div
    class="post 
      animated fadeInDown

    "
  >
    <div class="post-content">
      
      <div class="post-title">
        <h1>防缓存击穿利器singleflight介绍</h1>
        
          <div class="info">
            <em class="fas fa-calendar-day"></em>
            <span class="date"
              >
                Sun, Nov 21, 2021


              </span
            >
            <em class="fas fa-stopwatch"></em>
            <span class="reading-time">阅读时间 6 分钟</span>
          </div>

        
      </div><h1 id="缓存击穿">缓存击穿</h1>
<p>一般一个并发量大的服务，往往会在服务和数据库之间增加一层缓存，来减轻数据库的压力，因为数据库在高并发时往往会是整个系统的瓶颈。大概的过程就是查询时，先从缓存中查询，缓存中查不到，则从数据库中查询，并把数据回填到缓存中，再返回给用户，那么下次用户访问同一份数据时，就可以命中缓存而不用访问数据库，以此减轻数据库的压力。而在系统刚启动时一般也会采用<strong>缓存预热</strong>的方式，把数据库中的一些可能的热点数据预先加载到缓存中，以防止系统刚刚启动时数据库的压力过大。</p>
<p>而缓存中的key往往都需要有过期时间，当缓存中(Redis或者Memcached)的某个热点key，在承受大量并发时突然过期，导致查询这个key的所有请求穿透缓存到达数据库，增大数据库的压力，严重时甚至可能让数据库宕机，这就是<strong>缓存击穿</strong>。就像下图这样，所有请求都透传到了数据库：</p>
<p><img src="/images/singleflight/problem.png" alt=""></p>
<p>解决这个问题比较重型的武器是分布式锁，即缓存miss后访问数据库需要先获取分布式锁，拿到分布式锁后才能从数据库中查到想要的数据，没拿到分布式锁就需要等待其他占有锁的线程完成从数据库中取数据和缓存的回填操作后，再从缓存中获取数据并返回。</p>
<p>但是这种解决方式消耗资源过大，且并且不是每个系统都需要分布式锁。<a href="https://pkg.go.dev/golang.org/x/sync/singleflight">singleflight</a>就是一个解决该问题的利器。</p>
<h1 id="singleflight的使用">Singleflight的使用</h1>
<p>singleflight 库，直译过来就是单飞，这个库的主要作用就是将一组相同的请求合并成一个请求，实际上只会去请求一次，然后对所有的请求返回相同的结果即可。当并发访问数据库中某个数据时，可以通过singleflight保证在一定的时间周期内，同一个key的并发访问实际上只有一次请求真正访问数据库，以此来大大降低数据库的压力，如下图：</p>
<p><img src="/images/singleflight/singleflight.png" alt=""></p>
<h2 id="使用方式">使用方式</h2>
<p>首先获取这个包</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go get golang.org/x/sync/singleflight
</code></pre></div><p>Singleflight的全部代码只有一个文件<code>golang.org/x/sync/singleflight/singleflight.go</code>，十分简洁。</p>
<p>核心的结构体是<strong>Group</strong>，它有如下三个方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Do():  相同的 key，fn 同时只会执行一次，返回执行的结果给fn执行期间，所有使用该 key 的调用
</span><span style="color:#75715e">// v: fn 返回的数据
</span><span style="color:#75715e">// err: fn 返回的err
</span><span style="color:#75715e">// shared: 表示返回数据是调用 fn 得到的还是其他相同 key 调用返回的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>)) (<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">shared</span> <span style="color:#66d9ef">bool</span>) {
    
<span style="color:#75715e">// DoChan(): 类似Do方法，以 chan 返回结果
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">DoChan</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>)) <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Result</span> {
<span style="color:#75715e">// Forget(): 失效 key，后续对此 key 的调用将执行 fn，而不是等待前面的调用完成
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">Forget</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>)
</code></pre></div><ul>
<li>Do()：是执行方法，接收一个key，一个func()，对于同一个key，func()只会执行一次。func()方法返回一个interface{}和一个error</li>
<li>DoChan()：和Do类似，但是是以chan返回结果</li>
<li>Forget()：失效一个key，后续对这个key调用Do()时，还要执行func()，而不是等待其他的Do调用完成</li>
</ul>
<h4 id="do方法的使用">Do()方法的使用</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}

	<span style="color:#75715e">// 定义一个Group对象
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">singleflight</span>.<span style="color:#a6e22e">Group</span>{}
	
	<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;test-key&#34;</span>

	<span style="color:#75715e">// 开10个goroutine，并发调用Do方法
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span>{
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>){
			<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">shared</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">key</span>, <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
				<span style="color:#75715e">// 每一个执行方法，都打印一下key，和协程号
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">i</span>)
				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>, <span style="color:#66d9ef">nil</span>
			})
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>{
				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
				<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
				<span style="color:#66d9ef">return</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;goroutine: %d, v: %v, shared: %v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">shared</span>)
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}(<span style="color:#a6e22e">i</span>)
	}
	
	<span style="color:#75715e">// 等待所有协程执行完
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()	
}
</code></pre></div><p>上面这个程序的打印结果是这样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">test</span><span style="color:#f92672">-</span><span style="color:#a6e22e">key</span> <span style="color:#ae81ff">5</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">8</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">7</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
</code></pre></div><p>可以看到，只有5号 goroutine 执行了打印方法，所有的goroutine拿到的v都是5，都是共享的。</p>
<p>但偶尔也会有这样的打印：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">test</span><span style="color:#f92672">-</span><span style="color:#a6e22e">key</span> <span style="color:#ae81ff">9</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">8</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">7</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">9</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">test</span><span style="color:#f92672">-</span><span style="color:#a6e22e">key</span> <span style="color:#ae81ff">2</span>
<span style="color:#a6e22e">goroutine</span>: <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">v</span>: <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">shared</span>: <span style="color:#66d9ef">false</span>
</code></pre></div><p>9 号 goroutine和 2 号 goroutine执行了方法，且 2 号 goroutine 没有和其他 goroutine 共享，这就说明Do()方法自己是有一定超时控制的，超过一定时间后将自动失效掉这个key。</p>
<h4 id="dochan的使用">DoChan()的使用：</h4>
<p>Do()的问题是通过阻塞的方式来控制下游请求，如果某一个得到数据的协程执行时间过长，就有可能导致其他协程超时，造成大量协程错误。因此singleflight提供了DoChan()方法，用channel来返回结果，因此就可以通过select多路复用的方法实现超时控制：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 其中一个协程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">DoChan</span>(<span style="color:#a6e22e">key</span>, <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
 	<span style="color:#75715e">// do execution stuff... 
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">err</span>
})

<span style="color:#75715e">// 设置500ms超时时间
</span><span style="color:#75715e"></span><span style="color:#a6e22e">timeout</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#ae81ff">500</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)

<span style="color:#75715e">// 保存结果
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#a6e22e">singleflight</span>.<span style="color:#a6e22e">Result</span>

<span style="color:#66d9ef">select</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">timeout</span>:
		<span style="color:#75715e">// 超时控制
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">result</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>:
		<span style="color:#75715e">// 接收到协程的执行结果
</span><span style="color:#75715e"></span>		<span style="color:#f92672">...</span>
}
</code></pre></div><h4 id="forget的使用">Forget()的使用：</h4>
<p>由于Do()或者DoChan()方法，都能控制一定时间内只有一个协程执行下游服务的请求，其他协程等待这个协程，但某些情况下，需要降低一下这个等待时间，比如当一个协程超过了10ms还没等到其他协程的结果时，就失效这个key，让另一个请求不再等待，可以发过去，稍微提高下游的一点并发，保证请求的成功率：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">shared</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">key</span>, <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>) {
    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
    	<span style="color:#75715e">// 执行时开一个新协程，等了超过10ms就让这个key失效
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Deleting key: %v\n&#34;</span>, <span style="color:#a6e22e">key</span>)
        <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">Forget</span>(<span style="color:#a6e22e">key</span>)
    }()
    <span style="color:#f92672">......</span>
   	<span style="color:#75715e">// 这里执行访问下游服务的逻辑
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">err</span>
})
</code></pre></div><h1 id="singleflight的底层原理">Singleflight的底层原理</h1>
<h4 id="主要结构体">主要结构体</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Group represents a class of work and forms a namespace in
</span><span style="color:#75715e">// which units of work can be executed with duplicate suppression.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Group</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>       <span style="color:#75715e">// protects m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>  <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">call</span> <span style="color:#75715e">// lazily initialized
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// call is an in-flight or completed singleflight.Do call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">call</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

	<span style="color:#75715e">// These fields are written once before the WaitGroup is done
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// and are only read after the WaitGroup is done.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">val</span> <span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>

	<span style="color:#75715e">// forgotten indicates whether Forget was called with this call&#39;s key
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// while the call was still in flight.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">forgotten</span> <span style="color:#66d9ef">bool</span>

	<span style="color:#75715e">// These fields are read and written with the singleflight
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// mutex held before the WaitGroup is done, and are read but
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// not written after the WaitGroup is done.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dups</span>  <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">chans</span> []<span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Result</span>
}

<span style="color:#75715e">// Result holds the results of Do, so they can be passed
</span><span style="color:#75715e">// on a channel.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Result</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Val</span>    <span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">Err</span>    <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">Shared</span> <span style="color:#66d9ef">bool</span>
}
</code></pre></div><p>Group结构体包括两个参数，一个mutex互斥锁，和一个map[string]*call，map的键就是我们执行Do()时传入的key，指向一个call对象，看注释map这个参数是懒加载的。</p>
<p>call结构体是一个正在执行的或者已经完成的函数调用，这里存储调用的接口，错误等信息：</p>
<ul>
<li>wg：sync.WaitGroup对象，用来阻塞协程</li>
<li>val：interface{}，记录结果，在wg.Wait()解除阻塞之前，只会被写入一次，保证“单飞”</li>
<li>err：error，记录错误信息</li>
<li>forgotten：bool，用来标识是否对key执行了Forget()方法，当这个call还在阻塞中时</li>
<li>dups：int，用来记录执行次数，当wg完成前被更新，当wg完成后就只会被读取</li>
<li>chans：[]chan&lt;- Result：是系列记录Result的chan</li>
</ul>
<p>Result结果体保存着执行结果，用于DoChan()方法。</p>
<h4 id="do函数">Do函数</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Do executes and returns the results of the given function, making
</span><span style="color:#75715e">// sure that only one execution is in-flight for a given key at a
</span><span style="color:#75715e">// time. If a duplicate comes in, the duplicate caller waits for the
</span><span style="color:#75715e">// original to complete and receives the same results.
</span><span style="color:#75715e">// The return value shared indicates whether v was given to multiple callers.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>)) (<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">shared</span> <span style="color:#66d9ef">bool</span>) {
    <span style="color:#75715e">// 首先加了个锁，防止多个Do同时执行
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
    
    <span style="color:#75715e">// 然后是map的初始化，懒加载就体现在这里了
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">call</span>)
	}
    
    <span style="color:#75715e">// 检查key是否在map中存在，要存在就得实现单飞了
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
        
       	<span style="color:#75715e">// 记录一下执行次数
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dups</span><span style="color:#f92672">++</span>
        
        <span style="color:#75715e">// 然后解锁
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
        
        <span style="color:#75715e">// 阻塞住
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()

        <span style="color:#75715e">// 解除阻塞后，先检查一下错误，区分了两种错误
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">panicError</span>); <span style="color:#a6e22e">ok</span> {
			panic(<span style="color:#a6e22e">e</span>)
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">errGoexit</span> {
			<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Goexit</span>()
		}
        
        <span style="color:#75715e">// 检查完错误，就可以返回了，这里面的流程实际上就是等，并没有真的访问下游
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span>, <span style="color:#66d9ef">true</span>
	}
    
    <span style="color:#75715e">// 如果没有这个key，就创建一个call出来
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">call</span>)
    <span style="color:#75715e">// 完后把wg加1，并把key指向这个call对象，然后解锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
	
    <span style="color:#75715e">// 最后执行这个call，执行完了就返回
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">doCall</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">fn</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dups</span> &gt; <span style="color:#ae81ff">0</span>
}
</code></pre></div><p>然后看看执行call的doCall()方法怎么实现的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// doCall handles the single call for a key.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">doCall</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">call</span>, <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>)) {
    <span style="color:#75715e">// 一开始是定义了两个变量，判断是doCall方法是否是正常执行的，和有没有recover
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">normalReturn</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
	<span style="color:#a6e22e">recovered</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>

    <span style="color:#75715e">// 这里的注释说，使用了两个defer来区分panic，实际上是要将本身的panic和我们传入的fn()执行时的panic区分开，避免死锁
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// use double-defer to distinguish panic from runtime.Goexit,
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// more details see https://golang.org/cl/134395
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
        
        <span style="color:#75715e">// 先判断一下，如果没有正常执行完，且也没有recover的话，就说明需要直接退出了，这种是致命的panic
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// the given function invoked runtime.Goexit
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">normalReturn</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">recovered</span> {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">errGoexit</span>
		}

        <span style="color:#75715e">// 然后要操作map了，map并发不安全，得先锁上
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
        <span style="color:#75715e">// 如果说没有执行Forget(),就把这个key删了
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">forgotten</span> {
			delete(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">key</span>)
		}
		
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">panicError</span>); <span style="color:#a6e22e">ok</span> {
            <span style="color:#75715e">// 如果是panic类型的错误，且已经被recover捕获到了，而且还有chan等着数据呢，就永远阻塞住，
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// 要是没有chan，就是执行的Do()方法，就可以直接panic
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// In order to prevent the waiting channels from being blocked forever,
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// needs to ensure that this panic cannot be recovered.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">chans</span>) &gt; <span style="color:#ae81ff">0</span> {
				<span style="color:#66d9ef">go</span> panic(<span style="color:#a6e22e">e</span>)
				<span style="color:#66d9ef">select</span> {} <span style="color:#75715e">// Keep this goroutine around so that it will appear in the crash dump.
</span><span style="color:#75715e"></span>			} <span style="color:#66d9ef">else</span> {
				panic(<span style="color:#a6e22e">e</span>)
			}
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">errGoexit</span> {
            <span style="color:#75715e">// 要退出的话，就不用做什么操作了
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// Already in the process of goexit, no need to call again
</span><span style="color:#75715e"></span>		} <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// 如果不是panic，或者errGoexit错误，就可以正常向所有chan中写Result了
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// Normal return
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">chans</span> {
				<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Result</span>{<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dups</span> &gt; <span style="color:#ae81ff">0</span>}
			}
		}
	}()

	<span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">normalReturn</span> {
				<span style="color:#75715e">// Ideally, we would wait to take a stack trace until we&#39;ve determined
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// whether this is a panic or a runtime.Goexit.
</span><span style="color:#75715e"></span>				<span style="color:#75715e">//
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// Unfortunately, the only way we can distinguish the two is to see
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// whether the recover stopped the goroutine from terminating, and by
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// the time we know that, the part of the stack trace relevant to the
</span><span style="color:#75715e"></span>				<span style="color:#75715e">// panic has been discarded.
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
					<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">newPanicError</span>(<span style="color:#a6e22e">r</span>)
				}
			}
		}()
		
        <span style="color:#75715e">// 这里在一个匿名函数里执行fn()，并且顺利的执行了fn，就是正常的，并且前面还用了一个recover()
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 找到fn()执行过程中的panic
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">fn</span>()
		<span style="color:#a6e22e">normalReturn</span> = <span style="color:#66d9ef">true</span>
	}()

	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">normalReturn</span> {
		<span style="color:#a6e22e">recovered</span> = <span style="color:#66d9ef">true</span>
	}
}
</code></pre></div><h4 id="dochan函数">DoChan()函数</h4>
<p>DoChan()和Do()类似，区别就是一个是同步等待，一个是异步返回：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// DoChan is like Do but returns a channel that will receive the
</span><span style="color:#75715e">// results when they are ready.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// The returned channel will not be closed.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">DoChan</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">error</span>)) <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Result</span> {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Result</span>, <span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">call</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dups</span><span style="color:#f92672">++</span>
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">chans</span> = append(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">chans</span>, <span style="color:#a6e22e">ch</span>)
		<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ch</span>
	}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">call</span>{<span style="color:#a6e22e">chans</span>: []<span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Result</span>{<span style="color:#a6e22e">ch</span>}}
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
	
    <span style="color:#75715e">// 这里是开了个goroutine异步执行call，具体在doCall中都进行判断区分了
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">doCall</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">fn</span>)

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ch</span>
}
</code></pre></div><h4 id="forget函数">Forget()函数</h4>
<p>Forget()函数非常简单，就是把key给删了，要注意的就是golang的map是并发不安全的，需要加锁：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Forget tells the singleflight to forget about a key.  Future calls
</span><span style="color:#75715e">// to Do for this key will call the function rather than waiting for
</span><span style="color:#75715e">// an earlier call to complete.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>) <span style="color:#a6e22e">Forget</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
        <span style="color:#75715e">// 先把call的forgotten置为true，通知doCall这个key已经被删了
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">forgotten</span> = <span style="color:#66d9ef">true</span>
	}
	delete(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">key</span>)
	<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
}
</code></pre></div><h1 id="singleflight使用的一些注意事项">Singleflight使用的一些注意事项</h1>
<h4 id="一个阻塞全员等待">一个阻塞，全员等待</h4>
<p>这个问题解决方式就是上述的结合DoChan()和select做超时控制。</p>
<h4 id="一个错误全部错误">一个错误，全部错误</h4>
<p>这个问题解决方案就是上述的开一个goroutine超时后执行Forget()，提高下游服务的并发，让错误时可以多试几次，提高成功率。</p>
</div>
    <div class="post-footer">
      <div class="info">
        
          <span class="separator"><a class="category" href="/categories/golang/">golang</a></span>




        

        
          <span class="separator"><a class="tag" href="/tags/golang/">golang</a><a class="tag" href="/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/">缓存击穿</a></span>




        
      </div>
    </div>

    
  </div>


          </div>
        </div>
      </main>
    </div><footer class="footer footer--base">
  <div class="by_farbox">
    <ul class="footer__list">
      <li class="footer__item">
        &copy;
        
          2021-2022

        
      </li>
      
    </ul>
  </div>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.bdc7b23aff63497a79433b3920b03e2473399d90ad4c2d87cf7c08d33d61966f.js"
    integrity="sha256-vceyOv9jSXp5Qzs5ILA&#43;JHM5nZCtTC2Hz3wI0z1hlm8="
    crossorigin="anonymous"
  ></script></body>
</html>
