---
title: "Go和Redis的限流方案总结"
date: 2022-04-18T04:29:55+08:00
Description: ""
Tags: [微服务, Redis, Go, Kratos]
Categories: [系统设计]
DisableComments: false
draft: true
---

# 限流

限流在保证服务可用性方面是十分重要的。尤其是在微服务架构下，若大量请求超过微服务的处理能力时，可能会将服务打跨，甚至产生雪崩效应，影响整体系统的整体稳定性。

限流顾名思义就是限制流量，服务主动的抛弃一些自己可能处理不了的请求，让自己的QPS保持在一定范围以内，尽管会丧失一些可用性，但是可以保证服务不会被拖垮，也是服务对自身的一种保护。

接下来我们看一下常用的限流算法。

## 计数器法

就是在固定时间窗口内对请求计数，与阈值进行比较判断是否需要限流，在每个时间节点，都会将计数器清零。

比如我想要保证QPS的阈值是100次请求每秒，那么我就可以以一秒作为一个时间窗口，每一秒开始的时候清空计数器，然后每过来一个请求我就进行累加，当超过100个请求，并且这一秒还没过去时，就拒绝余下的请求，直到下一秒的时间窗口开始。

![](/images/limit/jishu.png)

#### 时间临界点缺陷

这种限流方法的典型缺陷，就是当前一秒末和后一秒前之间突然涌入大量请求，但是都没达到计数器的阈值，这样的流量也不会被限制住。比如第一秒的后半秒秒内涌入了100个请求，下一秒的前半秒也涌入了100个请求，对于第一秒和第二秒来说，限流的阈值都没有达到，但是对于 0.5 - 1.5 这一秒内确涌入了200个请求。

![](/images/limit/peak.png)

## 滑动窗口算法

滑动窗口就是为了优化固定窗口的普通计数器法的时间临界点缺陷，它是把一个大的时间分成多个小窗口，每次大窗口向后滑动一个小窗口，并保证大的窗口内流量不会超过最大值。

比如可以维护一个1s的时间窗口，由10个小窗口组成，每个100ms，每经过100ms，就有一个小窗口离开大窗口，一个新的小窗口进入大窗口。

![](/images/limit/huadong.png)

这种方式本质上只是一种对普通计数法的改进，没有真正解决流量突发的问题。它的实现，就是找出数组中连续k个元素的最大值。这里有一份可以参考的[代码实现](https://github.com/kevinyan815/gocookbook/issues/26)。

## 漏桶算法

漏桶就是想象一个木桶，容积固定。每个请求都像一个水滴，流入到桶中，然后这个桶会以固定的速率流出这些请求，如果桶满了就返回错误。

![](/images/limit/loutong.png)

这种方式是流量最均匀的限流，可以用于保护数据库；但是由于强行让流出的速率恒定，也不适合电商抢购、微博热点等允许突然的流量尖峰的情况。

## 令牌桶

令牌桶是一个反向的漏桶，以恒定速度放入令牌，满了就不加令牌了。每个请求都先从桶里拿到令牌，能得到令牌才能继续向后执行。

只要有令牌就可以处理请求，所以令牌桶可以支持最大桶中容量的最大突发流量，但是由于向木桶中加令牌的速度是固定的，且容量有限，所以单位时间内可以处理的请求也能得到控制。

![](/images/limit/token.png)





# Reference

1. https://github.com/kevinyan815/gocookbook/issues/26
2. https://mp.weixin.qq.com/s/krrUFEHVBw4c-47ziXOK2w
3. https://lailin.xyz/post/go-training-week6-4-auto-limiter.html