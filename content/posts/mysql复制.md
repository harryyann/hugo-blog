---
title: "MySQL的复制"
date: 2021-05-06T17:09:30+08:00
Description: "详解MySQL的复制"
Tags: ["MySQL"]
Categories: [数据库]
DisableComments: false
---

# 复制

复制是让一台服务器的数据和其他服务器保持同步。MySQL的复制是通过binlog实现的，binlog有三种类型：

- **statement**：记录的就是SQL语句，优点是人类可读，并且占用空间较小，但是基于该类型binlog的复制可能会产生不一致，比如执行某个特定函数，在复制后的结果可能和之前不一样。
- **raw**：记录的是具体的每一行的变化细节，可以保证复制的正确性，保证数据一致，但是一行一行的记录占用空间较大。实际使用中采用raw的比较多。
- **mixed**：是statement和raw的结合，一般的语句修改都采用statement格式保存，当碰到一些可能引起复制不一致的函数时，改为采用raw保存。这样即能缩小日志占用空间，也可以保证复制的数据一致性。

## 复制的过程

1. 主库产生binlog
2. 备库的**IO线程**，请求主库的binlog，并将binlog保存到自己本地的中继日志relay log中
3. 备库的**sql线程**读取relay log，通过重放relay log完成复制

后续会进行详细说明，大体的过程如下图：

![图片来自《MySQL技术内幕》](/images/replication/replication1.png)

## 复制的效率问题

由于在网络正常的情况下，备库从主库拉取binlog并持久化到本地的relay log的速度是很快的，性能消耗的大头在sql线程重放relay log的过程，尤其是在MySQL5.6版本前，只有一个sql线程，这样所有在主库上并行的写入，到了备库同步时就变成了串行执行，效率自然跟不上，在5.6版本以后，MySQL增加了多sql线程的方案进行了优化，后续也会详细说明。

## 复制解决的问题

1. 高可用

   数据冗余在多个地方，防止单点失效。

2. 负载均衡

   写少读多的场景下，可以让写请求都走主库，读请求则分发到多个备库上，实现负载均衡，提高数据库集群读的效率。

# 复制的执行过程

![图片来自于<极客时间-MySQL实战45讲>](/images/replication/replication2.png)

#### 主库：

1. 当有一个写请求时，先写内存的undo log，undo log主要用于事务回滚和MVCC。
2. 然后数据会写入innodb的buffer pool的缓存页中。
3. 然后就是**redo log的两阶段提交**，先写redo log进入prepare阶段。
4. 然后写入binlog（此时其实就具备了复制的条件） ，主库会开启一个dump线程，用于接收备库的dump请求。
5. 然后就是redo log的commit，当提交成功就会返回给客户端，提交失败也没关系，因为这一步只是修改redo log而已，事务在redo log的prepare阶段就已经成功了，失败的话后续数据库会重新提交的。宕机也没关系，MySQL有**double write策略**，保证数据的正确性。

#### 备库

1. 备库的IO线程会向主库的dump线程进行请求读取binlog的数据，然后写入relay log中
2. 然后备库的sql线程会从relay log中读取日志，在本地重放。

备库也可以作为其他备库的主库，再把这份数据同步到备库的备库中，只需要开启一个参数`log_slave_updates`为`ON`即可在备库上也会在重放时生成binlog。

```mysql
Mysql> show variables like "log_slave_updates";
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| log_slave_updates | ON    |
+-------------------+-------+
```



# 复制的拓扑结构

MySQL主从复制的限制

1. 一个备库只能有一个主库，一个主库可以有多个备库。
2. 每个备库都要有一个全局唯一的服务器ID。

## 一主多从

![](/images/replication/replication3.png)

最常见的复制方式，从库间没有交互，都是一个主库的从库，一般从库都会设置成**readonly模式**，有几点好处：

1. 有时一些运营类的查询会放到备库上查，设置为只读可以防止误操作。
2. 防止主备切换时逻辑有bug，造成切换过程中出现双写，造成主备不一致。
3. 可以方便的用readonly状态判断节点角色。

适用场景

- **读写分离**，主库写，所有从库读，**少量写和大量读**时适合。可以把不同的从库，根据使用方式，设置不同的存储引擎，提高读的效率，比如如果既要支持事务又要全文搜索就可以主库用innodb，从库用MyISAM（innodb现在也支持搜索了）。
- 容灾，往往从库中有一台是用作灾难恢复的，不处理业务逻辑，放到远程数据中心。
- 某个备库，还可以作为培训、开发或测试使用的服务器。

## 主主复制

包含两台服务器，每个都是对方的主：

![](/images/replication/replication4.png)

适用场景：当两个不同地理位置的服务器，都需要拥有写入操作时。

冲突问题：同时写一行，或者同时插入一个自增的字段时，两个操作可能会产生冲突。

这种拓扑模式问题很大，很容易造成数据不一致。一般不会采用这种方式，更常见的是下面这种，被动模式的主主复制

#### 被动模式的主主复制

主主复制的其中一个主改成**readOnly模式**，可以避免普通主主复制的冲突问题，区别是其中一台服务器是**只读的被动服务器**。由于服务器的配置是对称的（即两个数据库表，存储引擎，配置等完全是一模一样的），所以故障转移和恢复很容易，不需要切换主备关系，只改下readOnly即可，其实就是个优化版本的主从复制。

要注意的是，主主复制只能有两个主，不能多个主构成一个环，那种结构非常脆弱，可能循环复制。



#### 一种常见的MySQL主从拓扑的结构

![](/images/replication/replication6.png)

A和A'为被动模式的主主复制，其余B、C、D都是A的从库，A库进行写和少量读，B、C、D处理读请求。当A出现故障时，把A'切换为新主。

#### 分发主库

当使用一主多从的模式下，当从库过多，每个从库一个IO线程会对主库造成较高负载，尤其是当一个很大的数据插入操作时，主库的负载会显著上升，因为多个从库同时请求这块大数据。

使用一个从库作为分发主库，它也是主库的从库，然后其他从库都作为这个从库的从库，分发主库的唯一作用就是向其他所有从库提供主库的binlog。并且因为分发主库不做任何的查询，所以可以设置存储引擎为blackhole。

```
Tips:blackhole

blackhole存储引擎，就像它的名字，只进不出，所有插入的数据都不会插入到B+树，只会记录binlog，一般也只用于分发主库的功能
```

![](/images/replication/replication5.png)

分发主库也会有问题，如果分发主库出问题了，那么所有复制都失效了，有点脆弱，所以分发主库也可以整一个备库，当主出问题时，进行主备切换，让复制不会中断。

# 复制的优势和不足

能显著提高读的效率，对于读多写少的业务场景非常有效。缺点是对写没什么提高，如果对写要求高的话，低价值的数据可以适用NoSQL，高价值的数据可以考虑TokuDB。

# 备库的延迟问题

## 检查主备数据是否一致的方式

有两个方法可以检查主备数据是否一致

1. percona-toolkit的pt-table-checksum工具，这个工具的原理就是给主库插入一条数据，然后看看备库中是否同步过去了
2. 在备库执行`show slave status`命令，字段`Seconds_Behind_Master`就显示了从库延迟了多少秒

```mysql
MariaDB [(none)]> show slave status\G
*************************** 1. row ***************************
......
Seconds_Behind_Master: 0
......
```

## 主备延迟的主要原因

在网络正常时，日志从主库传给从库的耗时是很短的，所以**主要是从库从relay log中重放导致的`Seconds_Behind_Master`的延迟。

### Relay log重放慢的原因

- 机器性能差，需要升级机器
- 从库的读压力大，可能需要水平拓展，
- 长事务
  - 大批量的删除、写入操作，不要在一个事务里，拆分成多个事务，执行间隙再睡一会
  - 大表的DDL操作，可以适用gh-ost工具
- 从库的sql线程的重放策略有问题，比如MySQL版本较低，sql线程只有一个

MySQL在5.6版本支持了多个sql线程尝试解决这个问题。

### 备库sql线程的并行复制

MySQL5.6以后支持了从库多个sql进行relay log的重放操作。可以通过参数`slave_parallel_workers`参数指定sql线程的数量，默认是0：

```mysql
Mysql> show variables like "slave_parallel_workers";
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| slave_parallel_workers | 0     |
+------------------------+-------+
```

#### 多个sql线程并行复制的事务执行顺序问题

**MySQL5.6的并行复制策略**

**按库分发**。即如果事务操作的是不同数据库，那么可以被分发给不同的线程执行。这种方案明显分发效率很低。如果主库有多个Database，并且各个Database的压力平衡，会有一定效果。这种方案对binlog，外键等没有任何要求。

**MariaDB的并行复制策略**

MariaDB的并行复制主要基于两点：

- 一个**组里提交的事务**(事务可以按组提交以提升效率)，一定不会修改同一行
- 主库上可以并行的事务，那么从库也一定可以

基于以上两点，MariaDB通过commit_id识别出同一组提交的事务，然后把每组的事务分发到多个线程执行，执行完一组，再执行下一组。

```
Tips:

同一组事务提交的时候，应该是在写binlog时，会有一个相同的commit_id，它是全局递增的，binlog种记录的每一行都会记录下commit_id
```

这种方案的不足：仍然无法解决大事务对主备延迟的影响。

**MySQL5.7的并行复制策略**

MySQL5.7提供了`slave_parallel_type`参数来控制并行复制策略

- DATABASE，那就是MySQL5.6的按库分发的策略
- LOGICAL_CLOCK，就是基于MariaDB的分发策略，进行了一点优化，MariaDB是在事务commit时确定的commit_id，而InnoDB的事务是两阶段提交的，当redo log处于prepare状态时，事务就已经是可以提交的了，事务的所有的关于锁的检查都已经处理完了，所以MySQL5.7版本中除了同一组提交的事务外，同时处于prepare到commit状态的事务也是可以并行执行的。

```
Tips：

LOGICAL_CLOCK有两个和binlog提交相关的参数可以设置
binlog_group_commit_sync_delay：表示延迟多少微妙才调用fsync写入磁盘
binlog_group_commit_sync_no_delay_count：表示累计多少次以后才调用fsync
以上两个参数可以人为的拉长binlog写入磁盘的时间，制造出更多同时处于prepare阶段的事务，从而提升从库的并发度，当然这也让主库增大了一点丢失binlog的风险
```

**MySQL5.7.22的并行复制策略**

MySQL5.7.22增加一个参数`binlog_transaction_dependency_tracking`，有三个可选值：

- COMMIT_ORDER：就是前面5.7的LOGICAL_CLOCK策略
- WRITESET：表示对于事务涉及更新的每一行，计算出这一行的hash值，组合成writeset，如果两个事务没有操作相同的行，就是说他们的writeset没有交集，就可以并行
- WRITESET_SESSION：在writeset基础上多了一个约束，即在主库上同一个线程先后执行的事务，在从库上也要保证先后顺序

## 备库延迟的解决方案

### 强制走主库方案

对请求做分类，对于需要更新后立刻获取最新结果的请求，就必须要发到主库；对于可以读到旧数据的请求，就可以走主库。

这种方案的缺点也很明显，如果所有的查询都不能读旧数据，那就纯纯单机数据库了。

### 更新后，读库之前先sleep一下

看起来不可靠，但是应用也很多。比如前端插入数据成功以后，就可以由Ajax直接把新数据显示在前端，而不是真的走查询数据库。等到用户再次刷新页面时，或者一段时间以后，再访问数据库，就相当于做了一个sleep操作。或者就直接在后端程序中判断，更新后的立刻查询，就要sleep一会再查。

这种方案明显是不准的，还是可能读到旧数据，但是微博就是这么做的。我们发出去的评论，暂时看不到其实也没太大关系。

### 判断主从是否有延迟，有延迟就等没延迟了再访问

有多种方法都可以完成这个判断

1. 通过查询从库的`Seconds_Behind_Master`参数，如果不等于0，就等这个值等于0了再执行查询。
2. 对比位点，分别读主库的`read_master_log_position`参数和从库的`exec_master_log_position`参数，对比看看一不一样，不一样就等一样了再查询，这种比1更准确一点。
3. 对比GTID，主库的`auto_position`值为1，说明开启了GTID，然后检查从库的`retrieved_gtid_set`和`executed_gtid_set`是否一致，不一致就等一致了再去读，也比方法1更准确。



4. 方法2或方法3配合**semi-sync**方案，确保主库在binlog已经发给了备库之后，再提交事务。关于semi-sync，后续会说明。



# IO线程的复制方案



## 异步方案



## 半同步方案

即semi-sync，在MySQL5.7中通过一下命令可以开启：

```mysql
set global rpl_semi_sync_master_wait_point = AFTER_SYNC;
```





## 全同步方案

MySQL5.7.17以后配合MGR集群，并且仅支持InnoDB引擎，只能在GTID模式下，binlog只能为raw格式。

