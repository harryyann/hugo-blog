---
title: "MySQL的索引"
date: 2021-04-20T17:39:38+08:00
Description: ""
Tags: [MySQL,数据结构]
Categories: [数据库]
DisableComments: false
draft: true
---

## 索引是什么

## 数据库索引

索引是一种数据结构，可以为不同的场景提供更好的性能。对于数据库来说，索引的功能就是**提高数据查询的效率**，但同时不可避免的也会增加数据写入的消耗。

### 常见的索引数据结构

- 哈希表：

  key-value形式的存储，可以O(1)时间复杂度查询，缺点是**只能等值查询**，没办法范围查询。

- 有序数组

  在**等值查询和区间查询**都非常优秀，等值查找用二分法，时间复杂度是O(logN)，区间查找就用二分先找到一个边界，然后向一侧遍历即可。缺点是**插入删除太麻烦**，每插入删除一条数据要动整个数组。所以只适用于**静态存储**，不怎么需要插入删除的场景下比较合适。

- 二叉搜索树

  特点是左子节点的值比右子节点小，所以也是二分法查找，这样查找插入删除都不差，时间复杂度都是O(logN)，缺点是当左子数或右子树中没值时**会退化成链表**，查找效率大大降低，并且也不支持范围查找。

- 二叉平衡树

  解决二叉搜索树可能退化成链表的问题，各方面都比较好了，但是只有二叉，数据大的时候，树的层数会很高，一次查询可能要很**多次访问磁盘**，查找效率依然不令人满意，并且同样不支持范围查找。

- B树

  B树就是多叉平衡树，为了二叉搜索树尽可能减少访问磁盘，把二叉升级为多叉，N值取决于数据块的大小，因为要控制树的深度，所以数据块越大，N值也会越大。B树是很**适合磁盘存储**的数据结构。

- 跳表

  跳表是在链表之上加上多层索引构成的，支持快速插入、查找、删除数据，时间复杂度都是O(logn)，并且调表也支持按照区间快速查找数据，看起来是比较完美的索引数据结构了，Redis采用了这种数据结构。

- B+树

  跳表虽然很好，并且实现也很简单，但是对磁盘IO上没有B树友好，所以Redis这样的内存数据库选用了，而对于大部分需要持久化到磁盘的数据库来说，还是需要更少磁盘IO的B树比较合适，B+树对B树做了两点数据结构上的优化：

  1. 叶子节点之间用链表连接了起来，以优化范围查询。
  2. B+树分成了索引节点和数据节点，索引节点不存数据，只让叶子节点存数据，这样做有两点好处：
     1. 查询效率会更加平衡，MySQL中的B+树一般是2-4层，索引节点不存储数据，只有数据节点存储数据，这就导致所有数据的访问都是2-4次磁盘IO就可以拿到数据了，很稳定。而B树所有节点都存储数据，虽然当数据在高层节点时，访问速度可以很快，但是是非常不平均的，高层的数据就快，底层的就慢，稳定性很差。
     2. 由于索引节点不存数据，所以一次IO可以拿到更多的索引值，而B树中索引节点有存储数据，如果不是我们想要的，就浪费了大量的空间，一次磁盘IO从B+树获取的信息量远大于B树。

这篇文章主要还是聚焦于MySQL的索引实现。

## B+树索引

![](/images/index/B+tree.png)

如上图所示是B+树的结构。可以看到是以页为单位存储数据的，MySQL中的页大小默认是16k。高层索引节点中只存索引的key，低层数据节点中才会存储value，并且数据页之间是以链表的形式连接起来的，包括不同索引页的叶子节点。并且链表的顺序是按照索引key的顺序存储的，当然这是为了方便按索引范围取数据。



## InnoDB对B+树索引的使用

#### InnoDB存储引擎支持的索引结构

- B+树索引
- 哈希索引：就是自适应哈希索引，数据存储在**buffer pool**中，这部分内容可以查看[InnoDB存储引擎特性](https://yanghairui.life/posts/innodb%E7%89%B9%E6%80%A7/)
- 全文索引

#### InnoDB存储引擎对表的组织

InnoDB是**索引组织表**。InnoDB存储引擎的每张表都会有一个主键，如果没有指定，InnoDB会生成一个名叫row_id的隐藏字段，作为该表的主键。总之InnoDB的表一定会有一个主键，**InnoDB会根据主键建立一颗B+树，存放表中的所有数据**。这颗B+树也是主键索引的B+树，一个表其实就是一颗主键索引的B+树。

除此之外，对于表的每一个索引，都会创建出一颗B+树，可以说，**一个表有几个索引，那么它就有几颗B+树存储在磁盘上**。

另外主键索引和其他类型的索引的结构不同。我们说过InnoDB是索引组织表，主键索引这颗B+树上存储着表的所有行数据，主键索引中的索引节点上存储的是主键值，而数据节点中存着的是主键和数据行，所以主键索引也叫**聚簇索引**。

而其他索引就没必要存储完整的数据行了，其他索引的索引节点上存储的是索引行的数据，然后叶子节点上存储的是索引行和对应的主键。

基于以上差别，主键索引查询和非主键索引查询时，**主键索引只需要搜索一次B+树**，而**非主键索引则需要搜索两次B+树**，一次根据索引列找到主键，然后再根据主键查询数据索引拿到数据行（后面根据主键值再查一次主键索引的操作被称为**回表**），才能获取到整行数据。

#### 索引的维护

B+树为了保持有序性，在插入新值时要做维护。如果插入的行在最后的话，就只需要在树的末尾添加，但如果是在树的中间插值，就需要**挪动后面的数据**空出位置。如果此时这一个数据页已经满了，就需要新申请一个数据页，然后把一些数据搬过去，称为**页分裂**，性能会受影响，同时空间也会有浪费。

删除数据时，如果页的利用率很低，会将数据**页合并**，就是页分裂的逆过程，同样性能也会受影响。

基于页分裂和页合并的特性，InnoDB在插入时，**尽可能的在最后按顺序插入**，在中间插入则有可能产生页分裂造成性能和空间的浪费。这也是**自增主键**的好处。

对于自增主键来说，在插入时，B+树是从结尾插入的，每次操作都是追加，不会有页分裂问题出现。同时自增主键的占用空间上也要比UUID之类要小，还不用担心重复的问题。自增主键还可以进行范围查询。

#### 覆盖索引

当可以通过直接扫描k索引树就能得到结果，而不需要回表时，这就称之为**覆盖索引**，覆盖索引可以大幅提升性能，是一种常用的优化手段。

如我们前面所说，非主键索引的B+树叶子节点中存放的的是索引值和主键，那么我们要通过这个索引查询到某个非主键的其他字段时，就需要根据得到的主键值，再查一次主键索引，从主键索引中拿到完整的数据行，再获取想要的字段，我们说过，一颗B+树大概2-4层，访问一次需要2-4次磁盘IO，我们访问了两颗B+树的话，实际上就需要4-8次磁盘IO，这样性能是很差的。所以如果要查的字段通过非主键索引就能拿到的话，那么性能就大幅提升了。

#### 联合索引

InnoDB不仅允许一个字段建一个索引，还可以多个字段一起建立一个索引，节省空间。联合索引就是多个字段一起建一个索引，

