---
title: "MySQL事务详解"
date: 2021-05-04T22:10:47+08:00
Description: "关于MySQL中的事务相关知识的整理"
Tags: [MySQL]
Categories: [数据库]
DisableComments: false

---

### 事务

事务就是一组原子性的SQL语句。这一组SQL语句要么全部执行成功，要么全部不执行。只要有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。事务处理系统需要包含以下四个特性(ACID)：

- 原子性(atomicity)

一个事务必须被看作 是不可分割的最小工作单元。不可能执行成功其中的一部分操作，要么全部提交成功，要么全部失败回滚。

- 一致性(consistency)

数据库总是从一个一致性的状态，转换到另一个一致性的状态。

- 隔离性(isolation)

一个事务所作的修改，在提交之前，通常对其他事务是不可见的。（后面再谈到事务的隔离等级的时候会解释为什么说"通常"）

- 持久性(durability)

一旦事务提交，那么所作的修改就会永久保存到数据库中。



### 事务隔离等级

关于上述的第三点，隔离性，实际上比较复杂。SQL标准中定义了四种隔离等级，规定了一个事务中所作的修改，哪些在事务内和事务间是可见的，哪些是不可见的。以下介绍一下四种隔离等级。



#### READ UNCOMMITTED(未提交读)

在未提交读这个级别下，所有事务中的修改，即使没有提交，其他事务也可以看到，这就叫做`脏读`。显而易见，这个级别会导致很多问题，并且性能上来说，也没有比其他隔离级别好很多，所以几乎是没人用的。

#### READ COMMITTED(提交读)

顾名思义，和上一个等级的差别就在于，该隔离等级下，每个事务是能读取到当前已提交的事务所作的修改，即一个事务在提交之前，对其他事务都是不可见的。这个等级是大多数数据库的默认隔离等级，但不是MySQL的。该级别下存在`不可重复读`的问题。

- 不可重复读

如果在一个事务执行过程中，有另一个事务从未提交状态，转变为了提交状态。那么那个事务所修改的行就会发生改变。如果在当前事务中前后两次查询这个行，就有可能两次查到的信息不一致。

#### REPEATABLE READ(可重复读)

顾名思义，和上一个等级的差别在于，这个等级解决了上述的不可重复读的问题，保证了在一次事务中多次读取同一行数据的结果是一致的。解决方法是，在第一次SELECT的时候缓存查询记录，然后在后续的SELECT中复用这个缓存。但是可重复读无法解决`幻读`的问题。

- 幻读

所谓幻读，就是指在某个事务中多次读取某个范围的记录时，另一个事务在该范围中插入了一条记录并提交，则该事务后续的某次读取会出现多了一行的问题，这一行叫幻行，这就叫幻读。



MySQL通过MVCC(多版本并发控制)和间隙锁(next-key locking)解决了幻读的问题。



#### SERIALIZABLE(可串行化)

最高的隔离级别。通过强制事务串行执行，避免前述的幻读的问题。可串行化隔离级别下会在每一行数据上都加锁，所以效率也是最低的。只有在非常需要保证数据的一致性的时候且可以接受没有并发的情况，才会采用该级别。

| 隔离级别 | 是否脏读 | 是否不可重复读 | 是否幻读 | 是否加锁 |
| -------- | -------- | -------------- | -------- | -------- |
| 未提交读 | 是       | 是             | 是       | 否       |
| 提交读   | 否       | 是             | 是       | 否       |
| 可重复读 | 否       | 否             | 是       | 否       |
| 可串行化 | 否       | 否             | 否       | 是       |

为了解决死锁的问题，不同的数据库都实现了各种死锁检测和超时机制。InnoDB目前的处理方式是：将持有最少行级排他锁的事务进行回滚。 



