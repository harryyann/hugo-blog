---
title: "MySQL的事务"
date: 2021-05-04T22:10:47+08:00
Description: ""
Tags: [MySQL]
Categories: [数据库]
DisableComments: false

---

### 事务

事务就是一组原子性的SQL语句。这一组SQL语句要么全部执行成功，要么全部不执行。只要有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。事务处理系统需要包含以下四个特性(ACID)：

- 原子性(atomicity)

一个事务必须被看作 是不可分割的最小工作单元。不可能执行成功其中的一部分操作，要么全部提交成功，要么全部失败回滚。

- 一致性(consistency)

数据库总是从一个一致性的状态，转换到另一个一致性的状态。

- 隔离性(isolation)

一个事务所作的修改，在提交之前，通常对其他事务是不可见的。（后面再谈到事务的隔离等级的时候会解释为什么说"通常"）

- 持久性(durability)

一旦事务提交，那么所作的修改就会永久保存到数据库中。



### 事务隔离等级

关于上述的第三点，隔离性，实际上比较复杂。SQL标准中定义了四种隔离等级，规定了一个事务中所作的修改，哪些在事务内和事务间是可见的，哪些是不可见的。以下介绍一下四种隔离等级。



#### READ UNCOMMITTED(未提交读)

在未提交读这个级别下，所有事务中的修改，即使没有提交，其他事务也可以看到，这就叫做`脏读`。显而易见，这个级别会导致很多问题，并且性能上来说，也没有比其他隔离级别好很多，所以几乎是没人用的。

#### READ COMMITTED(提交读)

顾名思义，和上一个等级的差别就在于，该隔离等级下，每个事务是能读取到当前已提交的事务所作的修改，即一个事务在提交之前，对其他事务都是不可见的。这个等级是大多数数据库的默认隔离等级，但不是MySQL的。该级别下存在`不可重复读`的问题。

- 不可重复读

如果在一个事务执行过程中，有另一个事务从未提交状态，转变为了提交状态。那么那个事务所修改的行就会发生改变。如果在当前事务中前后两次查询这个行，就有可能两次查到的信息不一致。

#### REPEATABLE READ(可重复读)

顾名思义，和上一个等级的差别在于，这个等级解决了上述的不可重复读的问题，保证了在一次事务中多次读取同一行数据的结果是一致的。解决方法是，在第一次SELECT的时候缓存查询记录，然后在后续的SELECT中复用这个缓存。但是可重复读无法解决`幻读`的问题。

- 幻读

所谓幻读，就是指在某个事务中多次读取某个范围的记录时，另一个事务在该范围中插入了一条记录并提交，则该事务后续的某次读取会出现多了一行的问题，这一行叫幻行，这就叫幻读。



MySQL通过MVCC(多版本并发控制)和间隙锁(next-key locking)解决了幻读的问题。



#### SERIALIZABLE(可串行化)

最高的隔离级别。通过强制事务串行执行，避免前述的幻读的问题。可串行化隔离级别下会在每一行数据上都加锁，所以效率也是最低的。只有在非常需要保证数据的一致性的时候且可以接受没有并发的情况，才会采用该级别。

| 隔离级别 | 是否脏读 | 是否不可重复读 | 是否幻读 | 是否加锁 |
| -------- | -------- | -------------- | -------- | -------- |
| 未提交读 | 是       | 是             | 是       | 否       |
| 提交读   | 否       | 是             | 是       | 否       |
| 可重复读 | 否       | 否             | 是       | 否       |
| 可串行化 | 否       | 否             | 否       | 是       |

### 死锁

死锁是指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶行循环的问题。比如以下两个事务：

```
START ACTION1;
UPDATE StockTable SET close=45 WHERE stock_id=4;
UPDATE StockTable SET close=19 WHERE stock_id=3;
COMMIT;
```

```
START ACTION2;
UPDATE StockTable SET high=20 WHERE stock_id=3;
UPDATE StockTable SET high=47 WHERE stock_id=4;
COMMIT;
```

以上两个事务当执行完第一条语句后，改行会被锁定，当他们都去执行第二条语句的时候，发现改行都被对方锁定，然后两个事务都会等待对方释放锁，而陷入死循环。除非有外部因素介入才能解除死锁。



为了解决死锁的问题，不同的数据库都实现了各种死锁检测和超时机制。InnoDB目前的处理方式是：将持有最少行级排他锁的事务进行回滚。 



死锁发生以后，只有部分或完全回滚其中一个事务才能打破死锁。所以应用程序在设计时需要考虑死锁导致的回滚，尽量添加超时重试机制。



### 事务日志

事务日志可以提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该行为持久化到磁盘的事务日志中。然后根据事务日志在后台慢慢把数据刷回磁盘。即采用事件日志时修改数据，需要写两次磁盘。

### 多版本并发控制(MVCC)

MySQL的大多数事务型存储引擎实现的都不是简单的行锁，由于行锁的开销较大，基于提升并发性的考虑，一般都会实现多版本并发控制(MVCC)，可以认为MVCC是行锁的一个变种，他在很多情况下避免了加锁操作，从而降低开销。



不同的存储引擎对MVCC的实现也不尽相同，典型的有乐观并发控制、悲观并发控制。以下简要索命InnoDB存储引擎的MVCC。

#### InnoDB的MVCC实现方式

InnoDB的MVCC，是通过在每行记录后面隐藏两个字段来实现的，两个字段一个保存了行的创建时间，另一个保存了行的过期时间(或删除时间)，当然存储的并非是时间戳，而是系统的版本号，系统版本号全局递增的，没开启一个新的事务，该事务就会把当前的系统版本号作为事务的版本号

